#!/usr/bin/perl
use warnings; use strict;
use Seq;
use Bio::Seq;
my ($sam_file,$genome_file,$ins_size,$te_idx,$te,$ltr) = @ARGV;
print "$0 <sam> <genome> <ins_size> <te_idx> <te_name> <ltr_len>\n" unless @ARGV;


############# put genome seq in hash  #########
my %genomes = Seq::seq_hash($genome_file);
my $tnt_len = length ($genomes{$te});  # transposon length


my $tar;
my $rds;
my $num;
my $num_eff;
my $num_f;
my $rex_te = '^(\d+[SH]\d+M|\d+M|\d+M\d+[SH])$';

################ the mainbody of code######################
my @aligns = scan_sam ($sam_file);
foreach my $read (@aligns){
	my @hits = split /############/,$read;
	my %cors = find (@hits );

	my $tar_cig = $cors{tar}{cig};
	my $te_cig = $cors{$te}{cig}; 
	
	if ( $tar_cig =~ /M/ and $te_cig =~ /M/){
		cross(%cors);
	}
	if($te_cig =~ /S/){
		te_start(%cors);
	}
	if($te_cig =~ /E/){
		te_end(%cors);
	}
	if($tar_cig =~ /S/){
		ge_start(%cors);
	}
	if($tar_cig =~ /E/){
		ge_end(%cors);
	}
}

#################### the mainbody of code ######################


sub scan_sam{
	my $file = shift @_;
	open my $fh , $file or die $!;
	my %reads;
	my @re;
	while (<$fh>){
		chomp;
		next if (/^@/);
		my $id = (split /\t/,$_)[0];
		if(! keys %reads){
			$reads{$id} = "$_";
		}elsif( exists $reads{$id}){
			$reads{$id} .= "############$_";
		}else{
			my ($g) = values %reads;
			push @re, $g;
			undef(%reads);
			$reads{$id} = "$_";
		}
	}
	return @re;
}	


sub find{
	$num ++;
	my @reads = @_;
	$rds = join "\n",@_; ## in order to print informative reads in one file 
	
	my %cors;
	my $cors_ref = \%cors;
	
	
	
	##############determine the reads at tnt1#############
	my %trans;  # select the most promising tnt reads
	foreach my $it (@reads){
		my($id,$flag,$chr,$pos,$mq,$cig,$nchr,$npos,$seq) = (split /\t/,$it)[0,1,2,3,4,5,6,7,9];
		#print "$id,$flag,$chr,$pos,$mq,$cig,$nchr,$npos,$seq\n";
		if (($chr =~ /$te/ and $nchr ne "=") or ($nchr =~ /$te/ and $chr != /$te/)){
			
			my $num_of_m;
			while ($cig =~ /(\d+)M/g){
				$num_of_m += $1;
			}
			if (exists $trans{nm} and $trans{nm} > $num_of_m){
				next;
			}
			
			$trans{chr} = $chr;
			$trans{nm} = $num_of_m;
			$trans{nchr} = $nchr;
			$trans{pos}  = $pos;
			$trans{npos} = $npos;
			$cors{$te}{seq} = $seq;
			$cors{$te}{id} = $id;
			(my $r = $flag ) =~ s/\w+(\d)s?/$1/;
			my $rc = (($flag =~ /r/)? -1:1); 
			$trans{cig} = (($cig =~ /H/)?$r*$rc:0);
			$cors{$te}{direc} = $rc;
		}	
	}
	
	######### save  pair alignment ###########
	############################################
	############################################
	
	
	#### if tnt are hard clipped, exacute following code to get the full sequence  at tnt#######
	foreach my $it (@reads){
		my($id,$flag,$chr,$pos,$mq,$cig,$nchr,$npos,$seq) = (split /\t/,$it)[0,1,2,3,4,5,6,7,9];	
		(my $r = $flag ) =~ s/\w+(\d)/$1/;  #  which reads   1 or 2 ?????
		my $rc = (($flag =~ /r/)? -1:1);    # -1 antisense   and 1 means sense strand

		my $test_n = (($cig !~ /H/)?$r*$rc:0);
		if (abs($trans{cig})== abs ($test_n) and ($trans{cig})*($test_n) > 0){
			$cors{$te}{seq} = $seq;
		}elsif(abs($trans{cig})== abs ($test_n)  and ($trans{cig})*($test_n) < 0){
			$cors{$te}{seq} = Seq::rev_com($seq);
		}
		
	}


	################  if tnt have long ltr execute following code#############
	my %alns;   ## key will be position;
	open BT, ("bowtie2 -x $te_idx -c '$cors{$te}{seq}' --local -a --quiet |samtools view -S -X - 2>/tmp/sam.tmp|") or die $!;
	my $aln_sc = 10;
	print "ididid :: $cors{$te}{id}\n";
	while (<BT>){
		next if (/^@/);
		chomp;	
		my ($pos,$cig,$as) = (split /\t/,$_)[3,5,11];
		my $s = $1 if ($as =~ /AS:i:(\d+)/);	
		print "aln:$_\n";
		if ($s > ($aln_sc - 10)){
			$alns{$pos} = $cig;
		}
		$aln_sc = $s;
	}

		
	my $te_pos;
	if ($cors{$te}{direc} == 1){
		($te_pos) = (sort {$a<=>$b} keys %alns)[-1];
	}else{
		($te_pos) = (sort {$a<=>$b} keys %alns)[0];
	}
	my $te_cig = $alns{$te_pos};
	my $te_cs = cigar($te_cig);
	$cors{$te}{pos} = $te_pos;
	$cors{$te}{cig} = $te_cs;


	############## collect information of reads at genome###############
	foreach my $it (@reads){
		my($id,$flag,$chr,$pos,$mq,$cig,$nchr,$npos,$seq) = (split /\t/,$it)[0,1,2,3,4,5,6,7,9]; 
		my $rc = (($flag =~ /r/)? -1:1);    # -1 antisense   and 1 means sense strand
		my $cs = cigar($cig);
		#### select informative reads######
		if ($chr =~ /$trans{nchr}/ and ($pos == $trans{npos})){
			$cors{tar}{cig} = $cs;       # simplified cigar: M S E Z
			$cors{tar}{direc} = $rc;      # reads direction
			$cors{tar}{id} = $id;	       # read id 
			$cors{tar}{pos} = $pos;       ### when reads if reverse complement the start loc of reads should plus the length of reads
			$cors{tar}{seq} = $seq ;
			$cors{tar}{chr} = $chr;
		}
	}
	return %cors;
}

sub cigar {
	my $cig = shift @_;

	my $len;		        #  reads length
	my $cs;                      #  simplified cigars 
	my ($m_l);					# match length
		
	while ($cig =~ /(\d+)([MSIH])/g){
		my $n = $1;
		my $c = $2;
		$len += $n;
		$m_l += $1 if ($c eq "M");
	}

	if ($m_l/$len > 0.95 ){
		$cs = "M";
	}else{
		if ( $cig =~ /^(\d+)[SH]/ and $1 >= 3){
			$cs .= "S:$1";
		}
		if ( $cig =~ /(\d+)[SH]$/ and $1 >= 3){
			$cs .= "E:$1";
		}else{
			$cs = "Z";
		}
	}
	return $cs;
}

sub cross {
	my %cors = @_;
	if ( $cors{$te}{direc} == 1 and $cors{$te}{pos} > ($tnt_len - $ins_size)){
		my ($ins_direc,$jun);
		if ($cors{tar}{direc} == 1){
			$ins_direc = "R";
			$jun = $cors{tar}{pos} + length ($cors{tar}{seq});
		}else{
			$ins_direc = "S";
			$jun = $cors{tar}{pos};
		}
		print "$cors{$te}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tCE\n";
		print STDERR "$rds\n";
		$num_eff ++;
	}elsif ( $cors{$te}{direc} == -1  and $cors{$te}{pos} < ($ins_size - length($cors{$te}{seq}))){
		my ($ins_direc,$jun);
		if ( $cors{tar}{direc} == 1 ){
			$ins_direc = "S";
			$jun = $cors{tar}{pos} + length($cors{tar}{seq});
		}else{
			$ins_direc = "R";
			$jun = $cors{tar}{pos};
		}
		print "$cors{$te}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tCS\n";
		print STDERR "$rds\n";
		$num_eff++;
	}else{
		$num_f ++;
	}
}

sub te_start{
	my %cors = @_;
	if($cors{$te}{cig} =~ /S:(\d+)/ and $cors{$te}{direc} == -1 ){
		my $l = $1;
		if ($cors{$te}{pos} <=2 ){
			my $que = substr($cors{$te}{seq},0,$l);
			( my $que_r = $que) =~ tr/ATCGatcg/TAGCtagc/;
			$que_r = reverse $que_r;
			my $ins_direc;
			my $sub;
			my $chr_t = $cors{tar}{chr};
			my $pos_t = $cors{tar}{pos};
			my $len_t = length $cors{tar}{seq};
			if($cors{tar}{direc} == 1){
				$ins_direc = "S";
				$sub = substr($genomes{$chr_t},$pos_t-1,$ins_size);
				my $jun = -1;
				my $m_r = 0.05;
				for my $i (0..(length ($sub)- length ($que))){
					my $s = substr($sub,$i,$l);
					my $diffcount = () = ($que ^ $s) =~ /[^\x00]/g;
					if ($diffcount/$l  < $m_r){
						$jun = $i;
						$m_r = $diffcount;
					}
				}
				if($jun != -1){
					$jun = $jun + $pos_t;
					print "$cors{$te}{id}\t$ins_direc\t$chr_t\t$jun\tTS\n";
					print STDERR "$rds\n";
				}else{
					$num_f ++;
				}
			}else{
				$ins_direc = "R";
				my $sub_start = $pos_t-$ins_size +$len_t;
				$sub = substr($genomes{$chr_t},$sub_start-1,$ins_size);
				my $jun = -1;
				my $m_r = 5;
				for my $i (0..(length ($sub)- length ($que))){
					my $s = substr($sub,$i,$l);
					my $diffcount = () = ($que_r ^ $s) =~ /[^\x00]/g;
					if ($diffcount < $m_r){
						$jun = $i;
						$m_r = $diffcount;
					}
				}
				if($jun != -1){
					$jun = $jun + $sub_start;
					print "$cors{$te}{id}\t$ins_direc\t$chr_t\t$jun\tTS\n";
					print STDERR "$rds\n";	
			}else{
					$num_f++;
				}
			}
		}else{
			$num_f ++;
		}
	}
}

sub te_end{
	my %cors = @_;
	if ($cors{$te}{cig} =~ /E:(\d+)/ and $cors{$te}{direc} == 1){
		my $l = $1;
		my $end_pos = $cors{$te}{pos} + length($cors{$te}{seq}) - $l;
		if ($end_pos >= $tnt_len-10 ){
			my $que = substr($cors{$te}{seq},-$l);
			( my $que_r = $que) =~ tr/ATCGatcg/TAGCtagc/;
			$que_r = reverse $que_r;
			my $ins_direc;
			my $sub;
			my $chr_t = $cors{tar}{chr};
			my $pos_t = $cors{tar}{pos};
			my $len_t = length $cors{tar}{seq};
			if($cors{tar}{direc} == 1){
				$ins_direc = "R";
				$sub = substr($genomes{$chr_t},$pos_t-1,$ins_size);
				my $jun = -1;
				my $m_r = 2 ;
				for my $i (0..(length ($sub)- length ($que))){
					my $s = substr($sub,$i,$l);
					my $diffcount = () = ($que_r ^ $s) =~ /[^\x00]/g;
					if ($diffcount <= $m_r){
						$jun = $i;
						$m_r = $diffcount;
					}
				}
				if($jun != -1){
					$jun = $jun + $pos_t;
					print "$cors{$te}{id}\t$ins_direc\t$chr_t\t$jun\tTE\n";
					print STDERR "$rds\n";
				}else{
					$num_f ++;
				}
			}else{
				$ins_direc = "S";
				my $sub_start = $pos_t+$len_t-$ins_size;
				$sub = substr($genomes{$chr_t},$pos_t-1,$ins_size);
				my $jun = -1;
				my $m_r = 2 ;
				for my $i (0..(length ($sub)- length ($que))){
					my $s = substr($sub,$i,$l);
					my $diffcount = () = ($que ^ $s) =~ /[^\x00]/g;
					if ($diffcount <= $m_r){
						$jun = $i;
						$m_r = $diffcount;
					}
				}
				if($jun != -1){
					$jun = $jun + $pos_t;
					print "$cors{$te}{id}\t$ins_direc\t$chr_t\t$jun\tTE\n";
					print STDERR "$rds\n";
				}else{
					$num_f ++;
				}
			}
		}
	}
}

sub ge_start{
	my %cors = @_;
	if($cors{tar}{cig} =~ /S:(\d+)/){
		my $l = $1;
		my $que = substr($cors{tar}{seq},0,$l);
		( my $que_r = $que) =~ tr/ATCGatcg/TAGCtagc/;
		$que_r = reverse $que_r; 
		my $len = (length $que ) ;
		my $sub_h = "AAAAA".substr($genomes{$te},0,$len+5);
		my $sub_t = substr($genomes{$te},-($len+5))."AAAAA";
		my $ma = match($que,$que_r,$sub_h,$sub_t);
		if ($ma != 0){
			my $ma_direc = $ma * $cors{tar}{direc};
			if (abs($ma_direc) == 3){
				my $ins_direc = "S";
				my $jun  = $cors{tar}{pos};
				print "$cors{tar}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tGS\n";
				print STDERR "$rds\n";
				$num_eff++;
			}elsif(abs ( $ma_direc )== 2 ) {
				my $ins_direc = "R";
				my $jun = $cors{tar}{pos};
				print "$cors{tar}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tGS\n";
				print STDERR "$rds\n";
				$num_eff++;
			}else{
				$num_f ++;
			}
		}else{
			$num_f ++;
		}
	}
}

sub ge_end{
	my %cors = @_;
	if($cors{tar}{cig} =~ /E:(\d+)/){
				my $l = $1;
				my $que = substr($cors{tar}{seq},-$l);
				( my $que_r = $que) =~ tr/ATCGatcg/TAGCtagc/;
				$que_r = reverse $que_r; 
				my $len = (length $que ) ;
				my $sub_h = "AAAAA".substr($genomes{$te},0,$len+5);
				my $sub_t = substr($genomes{$te},-($len+5))."AAAAA";
				my $ma = match($que,$que_r,$sub_h,$sub_t);
				if ($ma != 0){
					my $ma_direc = $ma * $cors{tar}{direc};
					if (abs($ma_direc) == 3){
						my $ins_direc = "R";
						my $jun = $cors{tar}{pos} + length($cors{tar}{seq})-$l;
						print "$cors{tar}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tGE\n";
						print STDERR "$rds\n";
						$num_eff++;
					}elsif ( abs($ma_direc) == 2 ){
						my $ins_direc = "S";
						my $jun = $cors{tar}{pos} + length($cors{tar}{seq})-$l;
						print "$cors{tar}{id}\t$ins_direc\t$cors{tar}{chr}\t$jun\tGE\n";
						print STDERR "$rds\n";
						$num_eff++;
					}else{
						$num_f++;
					}
				}else{
					$num_f++;
				}
	}else{
			$num++;
	}
}
sub match {
	my %relas;
	for my $j (0..1){
		for my $k (2..3){
			for my $i (0..10){
				my $que = $_[$j];
				my $q_l = length $que;
				my $sub = substr($_[$k],$i,$q_l);
				my $diffcount = () = ($que ^ $sub) =~ /[^\x00]/g;
				#print "$diffcount\t$len_q\n";
				my $direc = ($j==0?1:-1);
				$relas{$diffcount} = $direc*$k;
			}
		}
	}
	foreach (sort {$a<=>$b} keys %relas){
		if ( $_ <= 3){
			my $v = $relas{$_};
			return "$v";   #### return value SH  ST RH  RT  
		}else{
			return "0";
		}
		last;
	}
}

